/*******************************************************************************
 *  @file      task1.h
 *  @brief     Подпрограмма выполнения для темы 1
 *  @author    Young Sideways
 *  @date      19.02.2024
 *  @copyright young.sideways@mail.ru, Copyright (c) 2024. All right reserved.
 ******************************************************************************/

#pragma once

/*
    Тема 1. Двоичные деревья
        Задание.
            Построение  и обработка  двоичных  деревьев  поиска. Реализовать  программу, выполняющую  следующий набор
        операций с деревьями поиска:
        1. поиск вершины с заданным значением ключа с выводом счетчика числа появлений данного ключа
        2. добавление новой вершины в соответствии со значением ее ключа или увеличение счетчика числа появлений
        3. построчный вывод дерева в наглядном виде на основе процедур обхода:
            - в прямом порядке;
            - с помощью обратно-симметричного обхода;
    Рекомендации:
        1. Объявить и реализовать  подпрограмму поиска. Поиск  начинается с корня дерева и в цикле для каждой вершины
           сравнивается ее ключ  с заданным значением. При совпадении  ключей, поиск заканчивается с выводом значения
           счетчика числа появлений  данного ключа. При несовпадении поиск  продолжается в левом или правом поддереве
           текущей вершины.
        2. Объявить и реализовать рекурсивную подпрограмму добавления новой вершины в дерево. Подпрограмма использует
           один параметр-переменную, определяющую адрес текущей вершины.  Если при очередном вызове подпрограммы этот
           адрес равен nil/null, то  производится добавление  нового  элемента  с  установкой всех необходимых полей.
           В противном случае  продолжается поиск  подходящего  места для новой вершины  за счет  рекурсивного вызова
           подпрограммы с адресом левого или правого поддерева. При  совпадении ключей надо просто увеличить значение
           счетчика появлений.
        3. Объявить   и  реализовать  рекурсивные   подпрограммы  для   построчного   вывода   дерева   в   прямом  и
           обратно-симметричном порядке:
        4. Все процедуры обхода  должны выводить вершины с числом  отступов, пропорциональным  уровню вершины: корень
           дерева не имеет отступов, вершины первого уровня выводятся на 5 отступов правее, вершины 2-го уровня – еще
           на 5 отступов  правее и т.д. Для  этого в рекурсивные  подпрограммы  обхода надо  ввести второй формальный
           параметр - уровень этой вершины.
        5. Все процедуры обхода имеют похожую структуру. Например, процедура обхода в прямом направлении должна:
            a. проверить пустоту очередного поддерева;
            б. вывести в цикле необходимое число пробелов в соответствии с уровнем вершины;
            в. вывести информационную часть текущей вершины.
            г. вызвать рекурсивно саму себя для обработки своего левого поддерева с увеличением уровня на 1;
            д. вызвать рекурсивно саму себя для обработки своего правого поддерева с увеличением уровня на 1;
            е. Сравнение рассмотренных правил вывода двоичного дерева поиска приводится в следующей таблице.

    Главная программа должна предоставлять следующие возможности:
        1. создание дерева с заданным числом вершин со случайными ключами
        2. добавление в дерево одной вершины с заданным пользователем значением ключа
        3. поиск в дереве вершины с заданным ключом
        4. построчный вывод дерева в наглядном виде
*/

int task1();