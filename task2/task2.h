/*******************************************************************************
 *  @file      task2.h
 *  @brief     Ответы на 2 задание
 *  @author    Young Sideways
 *  @date      19.02.2024
 *  @copyright © young.sideways@mail.ru, 2024. All right reserved.
 ******************************************************************************/

/*
    Тема 2. Организация поиска в массиве данных при помощи специальных методов поиска.

    Задание. Реализовать программно метод хеш-поиска с разрешением конфликтов методом пустых ячеек.
    Исходные ключи – любые слова (например – фамилии). Размер хеш-таблицы должен задаваться в программе с помощью константы m.
    Преобразование числового кода ключа в значение индекса выполнить с помощью простейшей хеш-функции, которая берет остаток от целочисленного деления кода на размер хеш-таблицы (на константу m).
    В случае возникновения конфликта при попытке размещения в таблице нового ключа, для него ищется первое свободное по порядку место по формуле
    j = (( h (ключ) + i ) mod m ) + 1, где i = 0, 1, 2, . . . , m-2

    Программа должна выполнять следующие действия:
        добавление нового ключа в таблицу с подсчетом сделанных при этом сравнений
        поиск заданного ключа в таблице с подсчетом сделанных при этом сравнений
        вывод текущего состояния таблицы на экран
    После отладки программы необходимо выполнить ее для разных соотношений числа исходных ключей и размерности таблицы: взять 10 ключей и разместить их поочередно в таблице размерности 11, 13 и 17.
    Для каждого случая найти суммарное число сравнений, необходимое для размещения ключей и их поиска. Сделать вывод о влиянии количества пустых мест в таблице на эффективность поиска.
*/

/**
 *  Dev comment:
 *      За основу реализации взята моя личная реализация хеш-таблицы, базирующаяся на быстром лукапе по таблице посредством операции 'hash & size'
 *      Метод намного быстрее приложенного 'j = (( h (ключ) + i ) mod m ) + 1'.
 *      и так же как и с предложенным (в случае простых чисел) даёт хорошую колиззионность.
 *      Однако требует особого выравнивания размера таблице по границе бит размера.
 *
 *      Размер рассчитывается как '2^n - 1', что в нашем случае даёт значения:
 *          7   (0b111),
 *          15  (0b1111),
 *          31  (0b11111),
 *          63  (0b111111),
 *          127 (0b1111111),
 *          255 (0b11111111)
 *      и т.д
 *      Рассчитывается размер как 'фактический размер' = pow(2, ceil(log2('требуемый размер'))) - 1, что даёт правильное фактическое значение к ближайшему требуемому размеру по верхней границе
 *      из-за чего пункт с размером таблице невыполним
 *      п.с. фактическая реализация расчёта размера указана в \ref hastable.c@_private_hashtable_table_memory_align()
 */

#pragma once

int task2();
